<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Google Drive 連携 - げんかるく</title>
  <link href="css/base-style.css" rel="stylesheet" />
  <link href="css/gencalc3.css" rel="stylesheet" />
  <style>
    p {
      text-align: left;
      margin-left: 10px;
    }

    dl {
      margin-top: 20px;
      text-align: left;
    }

    dt {
      padding-left: 10px;
    }
  </style>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
</head>

<body>
  <div id="app">
    <h2>Google Drive 連携</h2>
    <h3>テスト中</h3>

    <p><a href="./">Back to げんかるく</a> </p>

    <p>本画面では、Google Driveのアプリデータフォルダを介して、ブラウザ間および端末間で《げんかるく》のデータを共有するための機能を提供します。</p>

    <dl>
      <dt>アプリデータフォルダ (Google Drive ガイドより抜粋)</dt>
      <dd>
        アプリが構成ファイルなどのアプリケーション固有のデータを保存するために使用できる特別な隠しフォルダです。
        アプリケーションデータフォルダは、その中にファイルを作成しようとすると自動的に作成されます。
        このフォルダには、ユーザーが直接操作してはならないファイルを保存します。
        このフォルダには自分のアプリからのみアクセスでき、このフォルダのコンテンツはユーザーやドライブアプリからは見えません。
      </dd>
      <dt>「Googleでログイン」機能が要求する権限</dt>
      <dd>
        Google ドライブでのアプリ独自の設定データの参照、作成、削除
        <p>最小限の権限を要求します。
        </p>
      </dd>
    </dl>

    <button type="button" @click="handleAuthClick" :disabled="isAuthButtonDisabled">{{ authorizeButtonText }}</button>
    <button type="button" @click="handleSignoutClick" :disabled="isSignoutButtonDisabled">Sign Out</button>
    <button type="button" @click="handleGetClick" :disabled="isGetButtonDisabled">Download Appdata</button>
    <button type="button" @click="handleExportClick" :disabled="isExportButtonDisabled">Export Appdata</button>
    <button type="button" @click="handleImportClick" :disabled="isImportButtonDisabled">Import Appdata</button>

    <p>{{ notification }}</p>

    <table style="width: 100%; table-layout: fixed; text-align: left;">
      <tr>
        <th>name</th>
        <th style="width: 40em;">id</th>
        <th>modifiedTime</th>
        <th>size</th>
      </tr>
      <tr v-for="item in remoteFiles" :key="item.id">
        <td>{{ item.name }}</td>
        <td>{{ item.id }}</td>
        <td>{{ item.modifiedTime }}</td>
        <td>{{ item.size }}</td>
      </tr>
    </table>

    <table style="table-layout: fixed;">
      <tr v-for="item in appdataComparisons" :key="item.id">
        <td>{{ item[0] }}</td>
        <td>{{ item[3] }}</td>
      </tr>
    </table>

    <hr />
  </div>

  <script>
    const CLIENT_ID = '507502242382-a7d868j5089106u313q7hd6js3i375l2.apps.googleusercontent.com';
    const API_KEY = 'AIzaSyCMehcHxbFkrej2jq_CT4TuAqQz01MTW6g';
    const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
    const SCOPES = 'https://www.googleapis.com/auth/drive.appdata';

    const APPDATA_NAME = 'localStorage.json';

    function overwriteObject(dst, src) {
      if (_.isPlainObject(dst) && _.isPlainObject(src)) {
        const srcKeys = Object.keys(src);
        for (const key of srcKeys) {
          dst[key] = src[key];
        }
        for (const key of Object.keys(dst)) {
          if (!srcKeys.includes(key)) delete dst[key];
        }
      }
      return dst;
    }

    const { createApp, onMounted, reactive, ref } = Vue

    createApp({
      setup() {
        let tokenClient;
        let gapiInited = false;
        let gisInited = false;
        let gapi;
        const isAuthButtonDisabled = ref(true);
        const isSignoutButtonDisabled = ref(true);
        const isGetButtonDisabled = ref(true);
        const isExportButtonDisabled = ref(true);
        const isImportButtonDisabled = ref(true);
        const authorizeButtonText = ref('Googleでログイン');
        const notification = ref('');
        const remoteFiles = reactive([]);
        const appdataComparisons = reactive([]);
        const localAppdata = reactive({});
        const remoteAppdata = reactive({});

        onMounted(() => {
          async function initializeGapiClient() {
            await gapi.client.init({
              apiKey: API_KEY,
              discoveryDocs: [DISCOVERY_DOC],
            });
            gapiInited = true;
            maybeEnableButtons();
          }

          function maybeEnableButtons() {
            if (gapiInited && gisInited) {
              isAuthButtonDisabled.value = false;
            }
          }

          const script1 = document.createElement('script');
          script1.src = 'https://apis.google.com/js/api.js';
          script1.onload = function () {
            gapi = window.gapi;
            gapi.load('client', initializeGapiClient);
          };

          const script2 = document.createElement('script');
          script2.src = 'https://accounts.google.com/gsi/client';
          script2.onload = function () {
            tokenClient = google.accounts.oauth2.initTokenClient({
              client_id: CLIENT_ID,
              scope: SCOPES,
              callback: '', // defined later
            });
            gisInited = true;
            maybeEnableButtons();
          };

          document.head.appendChild(script1);
          document.head.appendChild(script2);
        })

        const handleAuthClick = () => {
          tokenClient.callback = async (resp) => {
            if (resp.error !== undefined) {
              throw (resp);
            }

            authorizeButtonText.value = 'Refresh';
            isSignoutButtonDisabled.value = false;
            isGetButtonDisabled.value = false;
            isExportButtonDisabled.value = false;
            isImportButtonDisabled.value = false;

            const listFilesResp = await listFiles();
            remoteFiles.splice(0, remoteFiles.length, ...listFilesResp);
          };

          if (gapi.client.getToken() === null) {
            tokenClient.requestAccessToken({ prompt: 'consent' });
          } else {
            tokenClient.requestAccessToken({ prompt: '' });
          }
        }

        const handleSignoutClick = () => {
          const token = gapi.client.getToken();
          if (token !== null) {
            google.accounts.oauth2.revoke(token.access_token);
            gapi.client.setToken('');

            authorizeButtonText.value = 'Authorize';
            isSignoutButtonDisabled.value = true;
            isGetButtonDisabled.value = true;
            isExportButtonDisabled.value = true;
            isImportButtonDisabled.value = true;
          }
        }

        const handleGetClick = async () => {
          notification.value = 'processing...';

          try {
            const listFilesResp = await listFiles({
              q: `name = '${APPDATA_NAME}'`,
            });
            if (listFilesResp && listFilesResp.length > 0) {
              const fileId = listFilesResp[0].id;
              const getFileResp = await getFile(fileId);
              console.log(getFileResp);
              if (getFileResp) {
                const json = JSON.parse(getFileResp.body);
                overwriteObject(remoteAppdata, json);
                makeAppdataComparisonsOfLocalAndRemote();
                notification.value = 'Appdata download succeeded.';
              }
            } else {
              notification.value = 'No remote appdata.';
            }
          } catch (err) {
            console.error(err);
            notification.value = 'Operation failed.';
            alert(err);
          }
        }

        const handleExportClick = async () => {
          notification.value = 'processing...';

          const appdata = getLocalAppdata();
          createAppData(APPDATA_NAME, appdata, 'application/json');

          const listFilesResp = await listFiles();
          remoteFiles.splice(0, remoteFiles.length, ...listFilesResp);
        }

        const handleImportClick = () => {
          if (!remoteAppdata) {
            notification.value = 'No remote appdata.';
            return;
          }
          notification.value = 'processing...';

          const localKeys = Object.keys(localStorage);
          const remoteKeys = Object.keys(remoteAppdata).sort();
          remoteKeys.forEach(key => {
            localStorage.setItem(key, remoteAppdata[key]);
          });
          localKeys.filter(s => !remoteKeys.includes(s)).forEach(key => {
            localStorage.removeItem(key);
          });

          makeAppdataComparisonsOfLocalAndRemote();

          notification.value = 'Appdata import suceeded.';
        }

        function makeMultipartBody(parts, boundary) {
          const result = [];

          parts.forEach(part => {
            const name = part[0];
            const body = part[1];
            const headers = part[2];
            result.push(`--${boundary}`);
            Object.keys(headers).forEach(key => {
              result.push(`${key}: ${headers[key]}`);
            })
            result.push('');
            result.push(JSON.stringify(body));
          })
          result.push(`--${boundary}--`);

          return result.join('\r\n');
        }

        async function createAppData(name, appdata, contentType) {
          const boundary = '----====----====----';

          let method = 'POST';
          let path = '/upload/drive/v3/files';
          let metadata = {
            name: name,
            parents: ['appDataFolder'],
          };

          const listFilesResponse = await listFiles({
            q: `name = '${name}'`,
          });
          if (listFilesResponse && listFilesResponse.length > 0) {
            method = 'PATCH';
            path += `/${listFilesResponse[0].id}`
            metadata = {};
          }

          const parts = [];
          parts.push(['metadata', metadata, { 'Content-Type': 'application/json' }]);
          parts.push(['media', appdata, { 'Content-Type': contentType }]);

          const multipartBody = makeMultipartBody(parts, boundary);

          let response;
          try {
            response = await gapi.client.request({
              path: path,
              method: method,
              params: {
                uploadType: 'multipart',
              },
              headers: {
                'Content-Type': `multipart/related; boundary=${boundary}`
              },
              body: multipartBody,
            });
            console.debug(response);
            notification.value = 'Appdata upload succeeded.';
          } catch (err) {
            notification.value = err.message;
            return;
          }
        }

        function getLocalAppdata() {
          const result = {};
          Object.keys(localStorage).sort().forEach(key => {
            result[key] = localStorage.getItem(key);
          });
          overwriteObject(localAppdata, result);
          return result;
        }

        function makeAppdataComparisonsOfLocalAndRemote() {
          getLocalAppdata();
          const work = [];
          Object.keys(localAppdata).sort().forEach(key => {
            let localValue = localAppdata[key];
            if (_.isPlainObject(localValue)) {
              localValue = JSON.stringify(localValue);
            }
            let remoteValue = undefined;
            let compareresult = 'Local only';
            if (remoteAppdata && key in remoteAppdata) {
              remoteValue = remoteAppdata[key];
              if (_.isPlainObject(remoteValue)) {
                remoteValue = JSON.stringify(remoteValue);
              }
              if (localValue == remoteValue) {
                compareresult = 'Same';
              } else {
                compareresult = 'Different';
              }
            }
            work.push([key, localValue, remoteValue, compareresult]);
          });
          if (remoteAppdata) {
            const localValue = undefined;
            Object.keys(remoteAppdata).sort().forEach(key => {
              if (key in localAppdata) {
                return;
              }
              const remoteValue = JSON.stringify(remoteAppdata[key]);
              work.push([key, localValue, remoteValue, 'Remote only']);
            });
          }
          appdataComparisons.splice(0, appdataComparisons.length, ...work);
        }

        // files.list
        async function listFiles(params) {
          const request = {
            orderBy: 'modifiedTime desc',
            pageSize: 10,
            spaces: 'appDataFolder',
            fields: 'nextPageToken, files(id, name, modifiedTime, size)',
          };
          if (params) {
            Object.keys(params).forEach(key => {
              request[key] = params[key];
            });
          }
          try {
            const response = await gapi.client.drive.files.list(request);
            console.debug(response);
            return response.result.files;
          } catch (err) {
            console.error(err);
            throw err;
          }
        }

        // files.get
        async function getFile(fileId, params) {
          const request = {
            path: `/drive/v3/files/${fileId}`,
            method: 'GET',
            params: {
              alt: 'media',
            }
          }
          if (params) {
            Object.keys(params).forEach(key => {
              request.params[key] = params[key];
            })
          }
          try {
            const response = await gapi.client.request(request);
            console.debug(response);
            return response;
          } catch (err) {
            console.error(err);
            throw err;
          }
        }

        return {
          isAuthButtonDisabled,
          isSignoutButtonDisabled,
          isGetButtonDisabled,
          isExportButtonDisabled,
          isImportButtonDisabled,
          authorizeButtonText,
          notification,
          remoteFiles,
          appdataComparisons,
          handleAuthClick,
          handleSignoutClick,
          handleGetClick,
          handleExportClick,
          handleImportClick,
        }
      }
    }).mount('#app')
  </script>
</body>

</html>